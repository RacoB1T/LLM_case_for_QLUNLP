# 七、多智能体系统

---

实现通用人工智能是人类不懈追求的目标。在这一进程中，智能代理（Agent）或称智能体的概念应运而生。在该领域的初期阶段，智能代理主要依赖于强化学习方法进行构建。这种方法的优势在于，它能够让智能体在未知环境中自主学习，无需明确的人工干预。这使得强化学习广泛应用于从电子游戏到机器人控制等多个领域。然而，强化学习也面临一些挑战，包括长时间的训练周期、低效的采样方式以及在复杂环境中的不稳定性。尤其在面对真实世界任务时，这些问题尤为突出。

尽管如此，强化学习为智能体的自我学习和适应提供了坚实的基础。然而，这种方法也有其局限性。通过强化学习获得的知识通常难以转移到其他新任务中，这使得智能体在面对不同场景时，往往需要从头开始重新训练。虽然迁移学习等方法在一定程度上缓解了这一问题，提升了智能体的泛化能力，但效果仍未达到预期。与此同时，大型语言模型（LLM）展示了巨大的潜力，能够达到与人类相当的推理和规划能力水平。LLM的推理能力与人类自主代理的期望高度契合，能够感知环境、做出决策并采取行动。基于LLM的智能体正在迅速发展，能够理解并生成类似人类的指令，从而促进在各种复杂场景中的交互和决策。

## 一、 多智能体

基于单个智能体的启发性能力，基于LLM的多智能体系统被提出，旨在通过多个智能体的集体智慧和专业技能来解决更为复杂和动态的任务。多智能体系统更加关注智能体之间的交互、合作以及集体决策的过程。通过多个自主智能体的协作，系统可以高效应对更加复杂的任务。

与单智能体系统相比，多智能体系统具有以下优势：

1.   **专业化分工**：多智能体系统允许每个智能体专注于特定的任务或功能，从而提高整个系统的效率和效果。每个智能体根据自身的专长来处理任务，实现更优的资源分配。
2.   **增强的交互能力**：在多智能体系统中，智能体能够高效地相互沟通和协作，从而更好地应对复杂、动态的环境。通过智能体间的协作，信息共享和行动协调得以实现。
3.   **更高的灵活性与适应性**：多智能体系统因其成员的多样性而具备更强的适应性。当环境发生变化或出现新挑战时，智能体能够调整自身行为或重新组合与其他智能体的协作方式。
4.   **集体智慧**：多智能体系统能够汇聚多个智能体的知识和技能，形成超越任何单一智能体的能力。这种集体智慧在解决复杂问题时尤为重要，它能够从多个角度分析问题并提出全面的解决方案。
5.   **鲁棒性和容错性**：多智能体系统在设计时考虑了冗余机制，即使某些智能体失效，其他智能体仍然可以接管任务，确保系统的持续运行。这样的设计增强了系统的鲁棒性和容错性。
6.   **模拟真实世界的团队合作**：多智能体系统的设计理念借鉴了人类团队的合作方式，通过智能体之间的协作来完成任务。这样的合作不仅提高了工作效率，还使得系统更能适应现实世界中的挑战。

简单来说，智能体可以看作是独立的个体，它们能够接收外部信息并做出回应。大型语言模型（LLM）则是这些独立个体的大脑，负责指导它们如何完成任务。每个智能体由以下三个核心模块构成：

1.   **思考模块**：负责处理来自外部的各种信息（如文本、声音、图片等），并将其转化为计算机能够理解的形式进行分析。
2.   **记忆模块**：存储并应用以往的经验和知识，帮助智能体在面对新任务时做出更为精准的判断和决策。
3.   **工具调用模块**：允许智能体调用外部工具或资源（如数据库查询、API接口调用等），以增强其解决问题的能力。

当外部输入进入时，智能体首先通过多模态能力处理这些信息，并借助思考模块进行推理和规划。如果需要，智能体还可以通过工具调用模块采取行动，从而完成任务。通过这种设计，智能体能够在无需额外训练的情况下，更好地理解并应对复杂问题。

### 1.1 思考模块

思考模块是智能系统的核心组件，负责接收、处理信息并执行逻辑推理，最终产生所需的输出结果。该模块不仅涉及任务的识别与拆解，还包括自我优化与审视。一个高效的思考模块应具备以下几个技能：

1.   **语言理解与生成**：语言是传递信息的工具，它包含着说话人的意图、情感等深层次信息。通过先进的语言模型，智能系统能够高效地理解和生成语言，洞察用户的潜在需求，并准确把握任务要求。
2.   **推理与规划**：推理能力是从大量案例中提取规律的能力，而规划则是在已知起点和终点的前提下制定实现目标的步骤。随着技术的进步，这两者之间的界限逐渐模糊，推理与规划可以在同一个系统中协调工作，以确保任务顺利完成。
3.   **自我反省与持续学习**：优秀的智能系统应具备自我进化的机制，能够在外部环境变化或用户反馈的基础上不断改进决策质量。即使在面对陌生领域或挑战性任务时，系统也能够主动探索并解决问题。

### 1.2 记忆模块

与人类大脑的记忆系统类似，智能体也需要通过记忆机制存储和应用过去的经验，帮助其做出决策。然而，不同的是，LLM的记忆特性通常是静态的、基于参数的，无法记录个体历史的具体互动。为了克服这一局限，智能体必须具备外部记忆系统，用于保存其个人状态及过去的经验，从而使智能体能够更好地“记住”自身的历史。

1.   **知识记忆**：LLM通过大规模数据训练积累了丰富的知识，这些知识通过模型参数隐式存储，可以被视为一个庞大的知识库。这样的记忆使得智能体能够在多个领域中高效完成任务。
2.   **社会记忆**：社会记忆包括对社会角色的理解以及过去社交互动的记录。智能体的社会记忆部分通常依赖外部系统来存储，帮助智能体根据以往的经验和自身角色与他人进行有效互动。

### 1.3 工具调用模块

如同人类利用工具来辅助完成任务，智能体同样可以通过使用外部工具来增强其功能。通过引入工具调用模块，不仅可以减轻智能体的记忆压力，提升其专业技能，还能增加智能体决策的透明度和稳定性，提高其抵抗恶意攻击的能力。鉴于大语言模型在预训练阶段已积累了广泛的世界知识，这使得它们能够有效地解析和执行用户指令，从而简化了工具使用的流程，充分发挥智能体的潜力。智能体学习如何使用工具的方式类似于人类——它们可以通过少量实例提示或是人类的反馈来掌握工具的选择和使用技巧。

工具的选择不局限于特定的应用场景，而是更注重那些能够扩展语言模型功能的接口。借助这些工具，智能体的输出形式不再局限于文字，其操作范围也拓展到了多媒体领域。不过，当前大多数工具的设计初衷是服务于人类，对于智能体而言可能并非最理想的选项。因此，未来的发展方向之一可能是开发更适合智能体使用的、具有更高模块化水平的工具。此外，智能体自身也展现出了创造工具的能力，比如学习自动编写API调用代码或将现有工具整合成更强大的工具。

尽管智能体在各种任务中展现了出色的表现，但它们通常是作为独立的个体运作，缺乏与其他智能体之间的交流，这限制了它们的学习和成长。为了克服这一局限，研究人员正在探索促进智能体间合作的方法，旨在建立多智能体系统。在这个系统中，智能体主要通过自然语言进行沟通，这是一种对人类而言既直观又易于理解的交流方式。与单一智能体相比，多智能体系统拥有多方面的好处：

1.  **数量优势**：遵循专业化分工的原则，每个智能体专注于特定的任务。通过集合多个智能体的专业技能和领域知识，可以显著提高系统的整体效率和适应性。
2.  **质量优势**：当多个智能体共同面对同一问题时，它们可能会提出不同的见解。通过相互之间的交流和反馈，智能体能够不断完善自己的解决方案，有效避免错误信息的产生，从而提高回答的准确性和真实性。

## 二、案例一：MedAgents

本文将通过解析**ACL 2024 Findings**的一篇工作《MedAgents: Large Language Models as Collaborators for Zero-shot Medical Reasoning》来介绍多智能体系统。

---

>实现通用人工智能是人类不懈追求的目标。在这一进程中，智能代理（Agent）或称智能体的概念应运而生。在该领域的初期阶段，智能代理主要依赖于强化学习方法进行构建。这种方法的优势在于，它能够让智能体在未知环境中自主学习，无需明确的人工干预。这使得强化学习广泛应用于从电子游戏到机器人控制等多个领域。然而，强化学习也面临一些挑战，包括长时间的训练周期、低效的采样方式以及在复杂环境中的不稳定性。尤其在面对真实世界任务时，这些问题尤为突出。
>
>基于单个智能体的启发性能力，基于LLM的多智能体系统被提出，旨在通过多个智能体的集体智慧和专业技能来解决更为复杂和动态的任务。多智能体系统更加关注智能体之间的交互、合作以及集体决策的过程。通过多个自主智能体的协作，系统可以高效应对更加复杂的任务。

 ### 2.1 MedAgents

案例是来自**ACL 2024 Findings**的一篇工作《MedAgents: Large Language Models as Collaborators for Zero-shot Medical Reasoning》。该案例主要任务是利用大型语言模型在医疗领域内的零样本学习能力。MedAgents通过创建一个多学科协作(Multi-disciplinary Collaboration)环境，让基于LLM的智能体以角色扮演的方式参与到多轮次的讨论中，以此来提升LLM的专业知识和推理能力。

具体来说，MEDAGENTS框架通过以下五个关键步骤来实现这一目标：

1.  **专家聚集**（Expert Gathering）：聚集各个医学领域的专家。这些专家可以是真实的医学专业人士，也可以是由大型语言模型扮演的角色。
2.  **分析提议**（Analysis Proposition）：每个专家或由LLM扮演的专家角色会根据自己的专业知识提出对特定医疗案例的初步分析。
3.  **报告汇总**（Report Summarization）：将所有专家的初步分析汇总成一个综合报告。
4.  **协作咨询**（Collaborative Consultation）：专家们就报告中的内容进行多轮讨论，以解决存在的分歧并达成共识。
5.  **决策制定**（Decision Making）：在讨论的基础上，最终做出决策或给出解决方案。

下面是这篇论文的整体框架图。

![overview](D:\workspace\案例6-10\7.多智能体系统.assets\overview.png)

该研究侧重于零样本学习场景，即智能体在未接受特定任务训练的情况下也能有效解决问题。实验结果显示，在包括MedQA、MedMCQA、PubMedQA及MMLU在内的九个数据集上，MedAgents框架显著提升了LLM挖掘和应用医学知识以及扩展其推理能力的效果。此外，该框架的优势在于无需额外训练即可运行，这使其在实际应用中更加灵活高效。

接下来将使用这篇论文提供的源码完成多智能体系统的案例实现。

### 2.2 源码解析

1. 下载论文的源码：

   ```shell
   # 返回LLM目录
   cd ~/LLM
   
   # 创建agent文件夹
   mkdir agent
   cd agent
   
   # clone 源码https://github.com/gersteinlab/MedAgents.git
   git clone https://github.com/gersteinlab/MedAgents.git
   ```

2. 安装必要的依赖库：

   ```shell
   # 其他库在前面课程已安装
   pip install wrapt-timeout-decorator==1.4.0
   ```

3. 源码目录解析

   代码的目录结构如下：

   ```shell
   - MedAgents # 仓库主目录
   	- datasets # 存放案例数据集的目录里面存有MedQA数据集的测试集
   	- outputs # 程序运行后的结果目录
   	- pics # 存放图片的目录里面是框架图
   	- api_utils.py # 调用LLM的api服务的工具库（注源码使用的openai库版本较老与现有环境有冲突需要重写。下面会给出修改方式）
   	- data_utils.py # 处理数据集和LLM调用后的返回数据的格式化工具库。
   	- inference.sh # 推理脚本
   	- prompt_generator.py # LLM的prompt生成库，里面存放着所有调用LLM需要的prompt
   	- README.md # 仓库的RADEME
   	- requirements.txt # 仓库源码的依赖环境（里面有些三方库的版本过低与当前环境冲突不需要全部安装）
   	- run.py # 程序的运行入口
   	- utils.py # LLM调用的整个流程
   ```

4. 源码解析`run.py`

   ```python
   import os
   os.chdir('agent/MedAgents')
   import time
   from data_utils import MyDataset
   from api_utils import api_handler
   from string import punctuation
   import argparse
   import tqdm
   import json
   from utils import *
   
   if __name__ == '__main__':
       # 必要的参数
       parser = argparse.ArgumentParser()
       parser.add_argument('--model_name', default='qwen2_5-1_5b-instruct') # 模型名称我们使用qwen2_5-1_5b-instruct版本
       parser.add_argument('--dataset_name', default='MedQA') # 数据集名称
       parser.add_argument('--dataset_dir', default='./datasets/MedQA/') # 数据集所在目录
       parser.add_argument('--start_pos', type=int, default=21) # 从第几条数据开始
       parser.add_argument('--end_pos', type=int, default=50) # 在第几条数据结束
       parser.add_argument('--output_files_folder', default='./outputs/MedQA')# 输出保存的位置
       parser.add_argument('--method', type=str, default='syn_verif', choices=['syn_verif', 'syn_only', 'anal_only', 'base_direct', 'base_cot']) # 使用的多智能体策略
       parser.add_argument('--max_attempt_vote', type=int, default=3) # 最大尝试次数
       args = parser.parse_args()
   
       print(args)
   
       ### get handler
       if args.model_name in ['instructgpt', 'newinstructgpt', 'chatgpt', 'gpt4', 'qwen2_5-1_5b-instruct']: 
           handler = api_handler(args.model_name) # 创建一个LLM的api处理器。
       else:
           raise ValueError
   
       ### get dataobj
       dataobj = MyDataset('test', args, traindata_obj=None)
       ### set test range
       end_pos = len(dataobj) if args.end_pos == -1 else args.end_pos
       test_range = range(args.start_pos, end_pos)  # closed interval
       ### set output_file_name
       exact_output_file = f"{args.output_files_folder}/{args.model_name}-{args.method}"
       if not os.path.exists(args.output_files_folder):
           os.makedirs(args.output_files_folder)
       if not os.path.exists(exact_output_file):
           with open(exact_output_file, 'w') as file:
               pass  # 创建一个空文件
       input_prompt = {}
       for idx in tqdm.tqdm(test_range, desc=f"{args.start_pos} ~ {end_pos}"):
           raw_sample = dataobj.get_by_idx(idx)
           # 获取问题
           question = raw_sample['question'] if raw_sample['question'][-1] in punctuation else raw_sample['question'] + '?'
          	# 获取问题的id
           realqid = idx
           # 针对不同数据集进行不同的数据处理
           if args.dataset_name in ['MedQA', 'MedMCQA'] or 'MMLU' in args.dataset_name:
               options = raw_sample['options']
               gold_answer = raw_sample['answer_idx']
               # 调用LLM完成对一条数据的处理
               data_info = fully_decode(idx, realqid, question, options, gold_answer, handler, args, dataobj)
           elif args.dataset_name == 'PubMedQA':
               question = raw_sample['context'] + ' ' + question
               options = raw_sample['options']
               gold_answer = raw_sample['answer_idx']
               data_info = fully_decode(idx, realqid, question, options, gold_answer, handler, args, dataobj)
           elif args.dataset_name in ['MedicationQA']:
               options = ''
               gold_answer = raw_sample['answer_idx']
               data_info = fully_decode(idx, realqid, question, options, gold_answer, handler, args, dataobj)
           # 将处理完成的数据转换成json格式
           record = json.dumps(data_info)
           # 写入文件
           with open(exact_output_file, 'a') as f:
               f.write(record + '\n')
   ```

   原文使用了多种LLM对任务进行处理，我们在此需要添加需要使用的`qwen2_5-1_5b-instruct`类型。

   参数中的`method`是表示使用那种策略对测试数据进行处理：

   1.   `base_direct`是不使用任何策略直接将问题输入LLM获取答案。
   2.   `base_cot`是仅使用`cot`思维链来让LLM一步步分析问题获取答案。同样没有使用论文中的策略。
   3.   `anal_only`是仅使用论文中以及的专家聚集和分析提议两种策略获取答案。
   4.   `syn_only`是使用论文中以及的专家聚集、分析提议和报告汇总三种策略获取答案。
   5.   `syn_verif`是完整使用了专家聚集、分析提议、报告汇总、协作咨询最后决策制定的全流程获取最终答案。

   这5种方法在论文中也确实展现了作者的多智能体策略的强大性能。

5. 源码解析`api_utils.py`

   ```python
   import openai
   import time
   import random
   from wrapt_timeout_decorator import timeout
   from openai import OpenAI
   
   
   # 使用多智能体调用LLM
   @timeout(200) # 200 seconds timeout
   def generate_response_multiagent(client, engine, temperature, max_tokens, frequency_penalty, presence_penalty, stop, system_role, user_input):
       print("Generating response for engine: ", engine)
       start_time = time.time()
       # 因为版本问题，这里使用的openai调用接口和源码中不太一致
       response = client.chat.completions.create(
           model=engine,
           temperature=temperature,
           max_tokens=max_tokens,
           top_p=1, # top_p的意思是选择概率质量值之和达到top_p的概率分布采样结果
           frequency_penalty=frequency_penalty,
           presence_penalty=presence_penalty,
           stop=stop,
           messages=[  
                   {"role": "system", "content": system_role},
                   {"role": "user", "content": user_input}
               ],
           seed=42)
       end_time = time.time()
       print('Finish!')
       print("Time taken: ", end_time - start_time)
   
       return response
   
   @timeout(10) # 10 seconds timeout
   def generate_response(client, engine, temperature, max_tokens, frequency_penalty, presence_penalty, stop, input_text):
       print("Generating response for engine: ", engine)
       start_time = time.time()
       # 因为版本问题，这里使用的openai调用接口和源码中不太一致
       response = client.chat.completions.create(
           model=engine,
           temperature=temperature,
           max_tokens=max_tokens,
           top_p=1, # top_p的意思是选择概率质量值之和达到top_p的概率分布采样结果
           frequency_penalty=frequency_penalty,
           presence_penalty=presence_penalty,
           stop=stop,
           messages=[{"role": "user", "content": input_text}],
           seed=42)
       end_time = time.time()
       print('Finish!')
       print("Time taken: ", end_time - start_time)
       return response
   @timeout(20) # 20 seconds timeout
   def generate_response_ins(client, engine, temperature, max_tokens, frequency_penalty, presence_penalty, stop, input_text, suffix, echo):
       print("Generating response for engine: ", engine)
       start_time = time.time()
       # 因为版本问题，这里使用的openai调用接口和源码中不太一致
       response = client.chat.completions.create(
           model=engine,
           prompt=input_text,
           temperature=temperature,
           max_tokens=max_tokens,
           top_p=1, # top_p的意思是选择概率质量值之和达到top_p的概率分布采样结果
           suffix=suffix,
           frequency_penalty=frequency_penalty,
           presence_penalty=presence_penalty,
           stop=stop,
           echo=echo,
           logprobs=1,
           seed=42)
       end_time = time.time()
       print('Finish!')
       print("Time taken: ", end_time - start_time)
   
       return response
   
   class api_handler:
       def __init__(self, model):
           self.model = model
           self.client = OpenAI(
               api_key='EMPTY',
               base_url='http://localhost:8000/v1',
           )
           self.engine = self.client.models.list().data[0].id
       def get_output_multiagent(self, system_role, user_input, max_tokens, temperature=0,
                       frequency_penalty=0, presence_penalty=0, stop=None):
           max_attempts = 3
           for attempt in range(max_attempts):
               try:
                   response = generate_response_multiagent(self.client, self.engine, temperature, max_tokens, frequency_penalty, presence_penalty, stop, system_role, user_input)
                   if response.choices and response.choices[0].message and response.choices[0].message.content:
                       return response.choices[0].message.content
                   else:
                       return "ERROR." 
               except (Exception) as error:
                   print(f'Attempt {attempt+1} of {max_attempts} failed with error: {error}')
                   if attempt == max_attempts - 1:
                       return "ERROR."
       def get_output(self, input_text, max_tokens, temperature=0,
                      suffix=None, stop=None, do_tunc=False, echo=False, ban_pronoun=False,
                      frequency_penalty=0, presence_penalty=0, return_prob=False):
           try:
               response = generate_response(self.client, self.engine, temperature, max_tokens, frequency_penalty, presence_penalty, stop, input_text)
           except (Exception):    
               print("Timeout")
               try:
                   response = generate_response(self.client, self.engine, temperature, max_tokens, frequency_penalty, presence_penalty, stop, input_text)
               except (Exception):
                   print("Timeout occurred again. Exiting.")
                   response = "ERROR."
                   return response  # 直接返回空字符串
           if response.choices and response.choices[0].message and response.choices[0].message.content:
               x = response.choices[0].message.content
           else:
               print(response)
               x = "ERROR."  # 或者设置一个默认值 防止生成的response没有content造成问题
               return x
           if do_tunc: # do_tunc的意思是是否要截断 保证返回的值里没有换行符，Q:，Question:等
               y = x.strip() # strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。
               if '\n' in y:
                   pos = y.find('\n') # 这里的意思是找到第一个换行符的位置
                   y = y[:pos] # 这里的意思是把第一个换行符之前的内容保留
               if 'Q:' in y:
                   pos = y.find('Q:')
                   y = y[:pos]
               if 'Question:' in y:
                   pos = y.find('Question:')
                   y = y[:pos]
               assert not ('\n' in y)
               if not return_prob:
                   return y
           if not return_prob:
               return x
           output_token_offset_real, output_token_tokens_real, output_token_probs_real = [], [], []
           return x, (output_token_offset_real, output_token_tokens_real, output_token_probs_real)
   ```

   源码中调用LLM采用的是0.27.4版本的`openai`但是本案例采用的是1.53.0版本。所以接口不太一致需要修改。上面是修改后的版本。

6. 源码解析`data_utils.py`

   ```python
   import os
   import jsonlines
   import re
   from nltk.tokenize import sent_tokenize
   from rouge_score import rouge_scorer
   # dataset 类
   class MyDataset:
       def __init__(self, split, args, eval_only=False, traindata_obj=None):
           #self.counter = 0
           if hasattr(args, 'start_pos'):
               self.start_pos = args.start_pos
           if hasattr(args, 'end_pos'):
               self.end_pos = args.end_pos
           if hasattr(args, 'model_name'):
               self.model_name = args.model_name
           self.dataset_name = args.dataset_name
           self.dir_path = args.dataset_dir
           self.split = split  # train / test
           self.load() # load dataset -> load data in self.data
           # load answers -> self.choice_ref / self.ref
           if args.dataset_name == 'MedQA':
               self.build_choice_ref_MedQA()
           elif args.dataset_name == 'MedMCQA' or 'MMLU' in args.dataset_name:
               self.build_choice_ref_MedMCQA()
           elif args.dataset_name == 'PubMedQA':
               self.build_choice_ref_MedMCQA()
           elif args.dataset_name == 'MedicationQA':
               self.build_ref()
       def load(self): # load dataset -> self.data
           filename = os.path.join(self.dir_path, self.split + '.jsonl')
           self.data = []
           with open(filename) as f:
               for item in jsonlines.Reader(f):
                   self.data.append(item)
       def get_by_idx(self, idx):
           return self.data[idx]
       def __len__(self):
           return len(self.data)
       def build_ref(self):
           self.ref = []
           for i in range(len(self)):
               item = self.get_by_idx(i)
               self.ref.append({'answers': {'text': item['answer']}, 'id': i})
       def build_choice_ref_MedQA(self):
           self.choice_ref = []
           for i in range(len(self)):
               item = self.get_by_idx(i)
               self.choice_ref.append({
                   'answers': {'text': item['answer'],'choice': item['answer_idx']}, 
                   'options': item['options'], 
                   'type': item['meta_info'],
                   'id': i})
       def build_choice_ref_MedMCQA(self):
           self.choice_ref = []
           for i in range(len(self)):
               item = self.get_by_idx(i)
               self.choice_ref.append({
                   'answers': {'text': item['answer'],
                   'choice': item['answer_idx']}, 
                   'options': item['options'], 
                   'id': i})
       def compute_rougescore(self, preds):
           sum_score = 0.0
           scorer = rouge_scorer.RougeScorer(['rouge1', 'rouge2', 'rougeL'], use_stemmer=True)
           for i, answer in enumerate(preds):
               correct_answer = self.ref[i]['answers']['text']
               # correct_answer = correct_answer.replace('\n', ' ')
               score = scorer.score(answer, correct_answer)
               sum_score += score['rouge1'].fmeasure
               # print(f'id: {i}, answer: {answer}, correct answer: {correct_answer}, rouge1 score: {score["rouge1"].fmeasure}')
               # print(score)
               # break
           return sum_score / len(preds)
       def compute_accuracy(self, preds):
           if 'PubMedQA' in self.dir_path:
               correct_num = 0.0
               all_num = 0.0
               for i, answer in enumerate(preds):
                   all_num += 1
                   correct_choice = self.choice_ref[i]['answers']['choice']
                   correct_answer = self.choice_ref[i]['answers']['text']
                   if answer == correct_choice or correct_answer in answer:
                       correct_num += 1
                   # print(f"id: {i}, choice: {answer}, correct choice: {correct_choice}")
               print(f"correct_num: {correct_num}, all_num: {all_num}")
               return correct_num / all_num
           elif 'MedQA' in self.dir_path:
               correct_num = {'step1': 0.0, 'step2&3': 0.0, 'all': 0.0}
               all_num = {'step1': 0.0, 'step2&3': 0.0, 'all': 0.0}
               for i, answer in enumerate(preds):
                   # choice = answer[:3]
                   answer = answer.strip()
                   all_num['all'] += 1
                   correct_choice = self.choice_ref[i]['answers']['choice']
                   correct_answer = self.choice_ref[i]['answers']['text']
                   type = self.choice_ref[i]['type']
                   all_num[type] += 1
                   if answer == correct_choice or (correct_choice in answer and answer != 'ERROR') or correct_answer in answer:
                       correct_num[type] += 1
                       correct_num['all'] += 1
                   # print(f"id: {i}, choice: {answer}, correct choice: {correct_choice}")
               print(f"correct_num: {correct_num}, all_num: {all_num}")
               return [correct_num[key] / all_num[key] for key in ['step1', 'step2&3', 'all']]
           elif 'MedMCQA' in self.dir_path or 'MMLU' in self.dir_path:
               correct_num = 0.0
               all_num = 0.0
               for i, answer in enumerate(preds):
                   # choice = answer[:3]
                   all_num += 1
                   correct_choice = self.choice_ref[i]['answers']['choice']
                   correct_answer = self.choice_ref[i]['answers']['text']
                   if answer == correct_choice or correct_answer in answer:
                       correct_num += 1
                   # print(f"id: {i}, choice: {answer}, correct choice: {correct_choice}")
               print(f"correct_num: {correct_num}, all_num: {all_num}")
               return correct_num / all_num
           
   # 用来清理不完整的句子
   def remove_incomplete_sentence(text):
       sentences = sent_tokenize(text)
       if len(sentences) > 1 and sentences[-1][-1] != '.':
           return ' '.join(sentences[:-1]) + '.'   #remove the last sentence
       else:
           return text
   
   '''
   analysis -> [domain1: analysis1, domain2: analysis2, ...]
   '''
   # 整理分析提议的输出
   def cleansing_analysis(analyses, domains, type):
       analysis = {}
       
       for i, item in enumerate(analyses):
           if item == "ERROR.":
               item = f"There is no analysis for this {type}."
           item = remove_incomplete_sentence(item)
           if "as an ai language model" in item.lower():
               end_index = item.lower().find("as an ai language model")+len("as an ai language model")
               item= item[end_index:].strip().strip(',').strip()
           analysis[domains[i]] = item
       
       return analysis
   # 整理报告汇总
   def cleansing_syn_report(question, options, raw_synthesized_report):
       tmp = raw_synthesized_report.split("Total Analysis:")
       try:
           total_analysis_text = tmp[1].strip()
       except:
           total_analysis_text = ""
       if "Key Knowledge" in tmp:
           key_knowledge_text = tmp[0].split("Key Knowledge:")[-1].strip()
           final_syn_repo = f"Question: {question} \n" \
               f"Options: {options} \n" \
               f"Key Knowledge: {key_knowledge_text} \n" \
               f"Total Analysis: {total_analysis_text} \n"
       else:
           final_syn_repo = f"Question: {question} \n" \
               f"Options: {options} \n" \
               f"Total Analysis: {total_analysis_text} \n"
       return final_syn_repo
   
   # 获取最后的输出的选项答案
   def cleansing_final_output(output):
       try:
           ans = output.split(":")[-1]
           ans = re.findall(r'A|B|C|D|E', ans)
           if len(ans) == 0:
               ans = ""
           else:
               ans = ans[0]
       except:
           ans = re.findall(r'A|B|C|D|E', ans)
           if len(ans) == 0:
               ans = ""
           else:
               ans = ans[-1]
       
       return ans, output
   # 整理协作咨询的投票
   def cleansing_voting(output):
       output = output.lower()
       ans = re.findall(r'yes|no', output)
       if len(ans) == 0:
           ans = "yes"
       else:
           ans = ans[0]
       return ans
   # 整理报告形式
   def transform_dict2text(analyses, type, content):
       if type == "question":
           report = ""
           i = 0
           for _domain, _analysis in analyses.items():
               report += f"Report{i} \n" \
                   f"Question: {content} \n" \
                   f"Domain: {_domain} \n" \
                   f"Analysis: {_analysis} \n\n"
               i += 1
       elif type == "options":
           report = ""
           i = 0
           for _domain, _analysis in analyses.items():
               report += f"Report{i}: \n" \
                   f"Options: {content} \n" \
                   f"Domain: {_domain} \n" \
                   f"Analysis: {_analysis} \n\n"
               i += 1
       return report
   
   ```

   这个程序文件主要用来进行数据集的处理，LLM回复数据的格式化和关键信息的提取。

7. 源码解析`utils.py`

   ```python
   from prompt_generator import *
   from data_utils import *
   def fully_decode(qid, realqid, question, options, gold_answer, handler, args, dataobj):
       question_domains, options_domains, question_analyses, option_analyses, syn_report, output = "", "", "", "", "", ""
       vote_history, revision_history, syn_repo_history = [], [], []
       if args.method == "base_direct":
           # 直接生成
           direct_prompt = get_direct_prompt(question, options)
           output = handler.get_output_multiagent(user_input=direct_prompt, temperature=0, max_tokens=50, system_role="")
           ans, output = cleansing_final_output(output)
       elif args.method == "base_cot":
           # 思维链生成
           cot_prompt = get_cot_prompt(question, options)
           output = handler.get_output_multiagent(user_input=cot_prompt, temperature=0, max_tokens=300, system_role="")
           ans, output = cleansing_final_output(output)
       else:
           # get question domains
           # 选择问题领域
           question_classifier, prompt_get_question_domain = get_question_domains_prompt(question)
           raw_question_domain = handler.get_output_multiagent(user_input=prompt_get_question_domain, temperature=0, max_tokens=50, system_role=question_classifier)
           if raw_question_domain == "ERROR.":
               raw_question_domain  = "Medical Field: " + " | ".join(["General Medicine" for _ in range(NUM_QD)])
           question_domains = raw_question_domain.split(":")[-1].strip().split(" | ")
   
           # get option domains
           # 选择选项领域
           options_classifier, prompt_get_options_domain = get_options_domains_prompt(question, options)
           raw_option_domain = handler.get_output_multiagent(user_input=prompt_get_options_domain, temperature=0, max_tokens=50, system_role=options_classifier)
           if raw_option_domain == "ERROR.":
               raw_option_domain  = "Medical Field: " + " | ".join(["General Medicine" for _ in range(NUM_OD)])
           options_domains = raw_option_domain.split(":")[-1].strip().split(" | ")
           # get question analysis
           # 分析问题
           tmp_question_analysis = []
           for _domain in question_domains:
               question_analyzer, prompt_get_question_analysis = get_question_analysis_prompt(question, _domain)
               raw_question_analysis = handler.get_output_multiagent(user_input=prompt_get_question_analysis, temperature=0, max_tokens=300, system_role=question_analyzer)
               tmp_question_analysis.append(raw_question_analysis)
           question_analyses = cleansing_analysis(tmp_question_analysis, question_domains, 'question')
           # get option analysis
           # 分析选项
           tmp_option_analysis = []
           for _domain in options_domains:
               option_analyzer, prompt_get_options_analyses = get_options_analysis_prompt(question, options, _domain, question_analyses)
               raw_option_analysis = handler.get_output_multiagent(user_input=prompt_get_options_analyses, temperature=0, max_tokens=300, system_role=option_analyzer)
               tmp_option_analysis.append(raw_option_analysis)
           option_analyses = cleansing_analysis(tmp_option_analysis, options_domains, 'option')
           if args.method == "anal_only":
               # 生成分析后的答案
               answer_prompt = get_final_answer_prompt_analonly(question, options, question_analyses, option_analyses)
               output = handler.get_output_multiagent(user_input=answer_prompt, temperature=0, max_tokens=2500, system_role="")
               ans, output = cleansing_final_output(output)
           else:
               # get synthesized report
               q_analyses_text = transform_dict2text(question_analyses, "question", question)
               o_analyses_text = transform_dict2text(option_analyses, "options", options)
               # 获取分析综合报告
               synthesizer, prompt_get_synthesized_report = get_synthesized_report_prompt(q_analyses_text, o_analyses_text)
               raw_synthesized_report = handler.get_output_multiagent(user_input=prompt_get_synthesized_report, temperature=0, max_tokens=2500, system_role=synthesizer)
               syn_report = cleansing_syn_report(question, options, raw_synthesized_report)
               if args.method == "syn_only":
                   # final answer derivation
                   # 根据分析综合报告生成答案
                   answer_prompt = get_final_answer_prompt_wsyn(syn_report)
                   output = handler.get_output_multiagent(user_input=answer_prompt, temperature=0, max_tokens=2500, system_role="")
                   ans, output = cleansing_final_output(output)
               elif args.method == "syn_verif":
                   all_domains = question_domains + options_domains
                   syn_repo_history = [syn_report]
                   hasno_flag = True   # default value: in order to get into the while loop
                   num_try = 0
                   while num_try < args.max_attempt_vote and hasno_flag:
                       domain_opinions = {}    # 'domain' : 'yes' / 'no'
                       revision_advice = {}
                       num_try += 1
                       hasno_flag = False
                       # hold a meeting for all domain experts to vote and gather advice if they do not agree
                       for domain in all_domains:
                           # 验证领域是否和报告一致
                           voter, cons_prompt = get_consensus_prompt(domain, syn_report)
                           raw_domain_opi = handler.get_output_multiagent(user_input=cons_prompt, temperature=0, max_tokens=30, system_role=voter)
                           domain_opinion = cleansing_voting(raw_domain_opi)   # "yes" / "no"
                           domain_opinions[domain] = domain_opinion
                           if domain_opinion == "no":
                               # 修订意见
                               advice_prompt = get_consensus_opinion_prompt(domain, syn_report)
                               advice_output = handler.get_output_multiagent(user_input=advice_prompt, temperature=0, max_tokens=500, system_role=voter)
                               revision_advice[domain] = advice_output
                               hasno_flag = True
                       if hasno_flag:
                           # 获取修订报告
                           revision_prompt = get_revision_prompt(syn_report, revision_advice)
                           revised_analysis = handler.get_output_multiagent(user_input=revision_prompt, temperature=0, max_tokens=2500, system_role="")
                           syn_report = cleansing_syn_report(question, options, revised_analysis)
                           revision_history.append(revision_advice)
                           syn_repo_history.append(syn_report)
                       vote_history.append(domain_opinions)
                   # final answer derivation
                   # 根据修订报告获取最后答案
                   answer_prompt = get_final_answer_prompt_wsyn(syn_report)
                   output = handler.get_output_multiagent(user_input=answer_prompt, temperature=0, max_tokens=2500, system_role="")
                   ans, output = cleansing_final_output(output)
       data_info = {
           'question': question,
           'options': options,
           'pred_answer': ans,
           'gold_answer': gold_answer,
           'question_domains': question_domains,
           'option_domains': options_domains,
           'question_analyses': question_analyses,
           'option_analyses': option_analyses,
           'syn_report': syn_report,
           'vote_history': vote_history,
           'revision_history': revision_history,
           'syn_repo_history': syn_repo_history,
           'raw_output': output
       }
       return data_info
   ```

   这里包含所有调用LLM智能体推理测试集问题的方法。

8. 源码解析`prompt_generator.py`

   ```python
   NUM_QD = 5
   NUM_OD = 2
   # question domains
   # 将问题分为五个不同的医学子领域
   """
   你是一名医学专家，专门将特定的医疗场景分类到特定的医学领域。
   “您需要完成以下步骤：”
   “1。仔细阅读问题中提出的医疗场景：“{问题}”。n
   “2。根据其中的医学场景，将问题分为五个不同的医学子领域。n
   “3。您应该以与“{question_domain_format}”完全相同的格式输出
   """
   def get_question_domains_prompt(question):
       question_domain_format = "Medical Field: " + " | ".join(["Field" + str(i) for i in range(NUM_QD)])
       question_classifier = "You are a medical expert who specializes in categorizing a specific medical scenario into specific areas of medicine."
       prompt_get_question_domain = f"You need to complete the following steps:" \
               f"1. Carefully read the medical scenario presented in the question: '''{question}'''. \n" \
               f"2. Based on the medical scenario in it, classify the question into five different subfields of medicine. \n" \
               f"3. You should output in exactly the same format as '''{question_domain_format}'''."
       return question_classifier, prompt_get_question_domain
   '''
   您是{question_domain}领域的医学专家。
   从您的专业领域，您将仔细检查和诊断患者在特定医疗场景中出现的症状。
   请仔细检查此问题中概述的医疗情况：”“{问题}”“。
   利用你的医学专业知识，解释所描述的情况。
   随后，确定并突出你认为最令人担忧或值得注意的问题方面。
   '''
   def get_question_analysis_prompt(question, question_domain):
       question_analyzer = f"You are a medical expert in the domain of {question_domain}. " \
           f"From your area of specialization, you will scrutinize and diagnose the symptoms presented by patients in specific medical scenarios."
       prompt_get_question_analysis = f"Please meticulously examine the medical scenario outlined in this question: '''{question}'''." \
                           f"Drawing upon your medical expertise, interpret the condition being depicted. " \
                           f"Subsequently, identify and highlight the aspects of the issue that you find most alarming or noteworthy."
   
       return question_analyzer, prompt_get_question_analysis
   '''
   作为一名医学专家，你有能力辨别出解决包含特定医学背景的多项选择题所需的两个最相关的专业领域。
   您需要完成以下步骤：
   1。仔细阅读问题中提出的医疗场景：“{问题}”。"
   2。可用选项为：“｛options｝”。努力理解问题和选项之间的基本联系。"
   3。你的核心目标应该是将这些选择分为两个不同的医学子领域。"
   您应该以与“{options.domain_format}”完全相同的格式输出
   '''
   def get_options_domains_prompt(question, options):
       options_domain_format =  "Medical Field: " + " | ".join(["Field" + str(i) for i in range(NUM_OD)])
       options_classifier = f"As a medical expert, you possess the ability to discern the two most relevant fields of expertise needed to address a multiple-choice question encapsulating a specific medical context."
       prompt_get_options_domain = f"You need to complete the following steps:" \
                   f"1. Carefully read the medical scenario presented in the question: '''{question}'''." \
                   f"2. The available options are: '''{options}'''. Strive to understand the fundamental connections between the question and the options." \
                   f"3. Your core aim should be to categorize the options into two distinct subfields of medicine. " \
                   f"You should output in exactly the same format as '''{options_domain_format}'''"
       return options_classifier, prompt_get_options_domain
   def get_options_analysis_prompt(question, options, op_domain, question_analysis):
       option_analyzer = f"You are a medical expert specialized in the {op_domain} domain. " \
                   f"You are adept at comprehending the nexus between questions and choices in multiple-choice exams and determining their validity. " \
                   f"Your task, in particular, is to analyze individual options with your expert medical knowledge and evaluate their relevancy and correctness."
   
       prompt_get_options_analyses = f"Regarding the question: '''{question}''', we procured the analysis of five experts from diverse domains. \n"
       for _domain, _analysis in question_analysis.items():
           prompt_get_options_analyses += f"The evaluation from the {_domain} expert suggests: {_analysis} \n"
           prompt_get_options_analyses += f"The following are the options available: '''{options}'''." \
                       f"Reviewing the question's analysis from the expert team, you're required to fathom the connection between the options and the question from the perspective of your respective domain, " \
                       f"and scrutinize each option individually to assess whether it is plausible or should be eliminated based on reason and logic. "\
                       f"Pay close attention to discerning the disparities among the different options and rationalize their existence. " \
                       f"A handful of these options might seem right on the first glance but could potentially be misleading in reality."
       return option_analyzer, prompt_get_options_analyses
   '''
   问题：｛问题｝\n选项：｛选项｝\n
   答案：让我们一步一步地解决这个问题，以确保我们有正确的答案。\n
   步骤1：正确解码问题。我们有一个专家团队，他们对这个问题进行了详细的分析。
   该团队包括来自与该问题相关的不同医学领域的五名专家。\n
   ｛_domain｝专家的见解表明，｛_analysis｝\n
   第2步：根据患者情景的具体情况以及您的医学知识，单独评估每个提出的选项。
   密切注意辨别不同选择之间的差异。
   其中一些选项乍一看可能是正确的，但在现实中可能会产生误导。
   我们有来自两个领域的专家的详细分析。\n
   ｛_domain｝专家的评估表明，｛_analysis｝\n
   步骤3：根据从上述步骤中获得的理解，选择最佳选项来回答问题。\n
   注意事项：\n
   1。所提供的分析应指导您做出正确的回答。
   2。任何包含错误信息的选项本质上都不是正确的选择。
   3。请仅使用所选选项的字母，如A、B、C、D或E，并使用以下格式进行回复：“选项：[所选选项字母]”。
   记住，这是我们需要的信件，而不是选项的全部内容。
   '''
   def get_final_answer_prompt_analonly(question, options, question_analyses, option_analyses):
       prompt = f"Question: {question} \nOptions: {options} \n" \
           f"Answer: Let's work this out in a step by step way to be sure we have the right answer. \n" \
           f"Step 1: Decode the question properly. We have a team of experts who have done a detailed analysis of this question. " \
           f"The team includes five experts from different medical domains related to the problem. \n"
       
       for _domain, _analysis in question_analyses.items():
           prompt += f"Insight from an expert in {_domain} suggests, {_analysis} \n"
       
       prompt += f"Step 2: Evaluate each presented option individually, based on both the specifics of the patient's scenario as well as your medical knowledge. " \
               f"Pay close attention to discerning the disparities among the different options. " \
               f"A handful of these options might seem right on the first glance but could potentially be misleading in reality. " \
               f"We have detailed analyses from experts across two domains. \n"
       
       for _domain, _analysis in option_analyses.items():
           prompt += f"Assessment from an expert in {_domain} suggests, {_analysis} \n"
       prompt += f"Step 3: Based on the understanding gathered from the above steps, select the optimal choice to answer the question. \n" \
           f"Points to note: \n" \
           f"1. The analyses provided should guide you towards the correct response. \n" \
           f"2. Any option containing incorrect information inherently cannot be the correct choice. \n" \
           f"3. Please respond only with the selected option's letter, like A, B, C, D, or E, using the following format: '''Option: [Selected Option's Letter]'''. " \
           f"Remember, it's the letter we need, not the full content of the option."
   
       return prompt
   
   '''
   这是一份综合报告：{syn_report}\n
   根据上述报告，选择最佳选项来回答问题。\n
   注意事项：\n
   1。所提供的分析应指导您做出正确的回答。
   2。任何包含错误信息的选项本质上都不是正确的选择。
   3。请仅使用所选选项的字母，如A、B、C、D或E，并使用以下格式进行回复：“选项：[所选选项字母]”。
   记住，这是我们需要的信件，而不是选项的全部内容。
   '''
   def get_final_answer_prompt_wsyn(syn_report):
       prompt = f"Here is a synthesized report: {syn_report} \n" \
           f"Based on the above report, select the optimal choice to answer the question. \n" \
           f"Points to note: \n" \
           f"1. The analyses provided should guide you towards the correct response. \n" \
           f"2. Any option containing incorrect information inherently cannot be the correct choice. \n" \
           f"3. Please respond only with the selected option's letter, like A, B, C, D, or E, using the following format: '''Option: [Selected Option's Letter]'''. " \
           f"Remember, it's the letter we need, not the full content of the option."
       return prompt
   
   def get_direct_prompt(question, options):
       prompt = f"Question: {question} \n" \
           f"Options: {options} \n" \
           f"Please respond only with the selected option's letter, like A, B, C, D, or E, using the following format: '''Option: [Selected Option's Letter]'''."
       return prompt
   
   def get_cot_prompt(question, options):
       cot_format = f"Thought: [the step-by-step thoughts] \n" \
                   f"Answer: [Selected Option's Letter (like A, B, C, D, or E)] \n"
       prompt = f"Question: {question} \n" \
           f"Options: {options} \n" \
           f"Answer: Let's work this out in a step by step way to be sure we have the right answer. " \
           f"You should output in exactly the same format as '''{cot_format}'''"
       return prompt
   '''
   您是一位擅长根据来自不同领域专家的多位专家进行总结和综合的医疗决策者。
   关键知识：[提取的关键知识]\n
   总分析：[综合分析]\n
   以下是来自不同医学领域专家的一些报告。\n
   您需要完成以下步骤：
   1。仔细全面地考虑以下报告。
   2。从以下报告中提取关键知识。"
   3。根据知识推导出全面和总结的分析。"
   4。您的最终目标是根据以下报告生成一份精炼和综合的报告。"
   您应该以与“{syn_report_format}”完全相同的格式输出
   '''
   def get_synthesized_report_prompt(question_analyses, option_analyses):
       synthesizer = "You are a medical decision maker who excels at summarizing and synthesizing based on multiple experts from various domain experts."
       syn_report_format = f"Key Knowledge: [extracted key knowledge] \n" \
                   f"Total Analysis: [synthesized analysis] \n"
       prompt = f"Here are some reports from different medical domain experts.\n "
       prompt += f"You need to complete the following steps:" \
                   f"1. Take careful and comprehensive consideration of the following reports." \
                   f"2. Extract key knowledge from the following reports. " \
                   f"3. Derive the comprehensive and summarized analysis based on the knowledge." \
                   f"4. Your ultimate goal is to derive a refined and synthesized report based on the following reports." \
                   f"You should output in exactly the same format as '''{syn_report_format}'''"
       prompt += question_analyses
       prompt += option_analyses
       
       return synthesizer, prompt
   
   '''
   您是｛domain｝领域的医学专家。
   这是一份医疗报告：{syn_report}
   作为{领域}的医学专家，请仔细阅读本报告，并决定您的意见是否与本报告一致。
   请只回答：[是或否]。
   '''
   def get_consensus_prompt(domain, syn_report):
       voter = f"You are a medical expert specialized in the {domain} domain."
       cons_prompt = f"Here is a medical report: {syn_report} \n"\
           f"As a medical expert specialized in {domain}, please carefully read the report and decide whether your opinions are consistent with this report." \
           f"Please respond only with: [YES or NO]."
       return voter, cons_prompt
   '''
   这是一份医疗报告：{syn_report}
   作为{领域}的医学专家，请充分利用您的专业知识对本报告提出修订建议。
   您应该以与“修订：[拟议修订建议]”完全相同的格式输出
   '''
   def get_consensus_opinion_prompt(domain, syn_report):
       opinion_prompt = f"Here is a medical report: {syn_report} \n"\
           f"As a medical expert specialized in {domain}, please make full use of your expertise to propose revisions to this report." \
           f"You should output in exactly the same format as '''Revisions: [proposed revision advice] '''"
       return opinion_prompt
   #revision_prompt = get_revision_prompt(revision_advice)
   '''
   这是原始报告：｛syn_report｝
   以下是专门从事{领域}的医学专家的建议：{建议}。
   根据上述建议，以与“总分析：[修订分析]”完全相同的格式输出修订后的分析
   '''
   def get_revision_prompt(syn_report, revision_advice):
       revision_prompt = f"Here is the original report: {syn_report}\n\n"
       for domain, advice in revision_advice.items():
           revision_prompt += f"Here is advice from a medical expert specialized in {domain}: {advice}.\n"
       revision_prompt += f"Based on the above advice, output the revised analysis in exactly the same format as '''Total Analysis: [revised analysis] '''"
       return revision_prompt
   ```

   这里保存了所有的`prompt`。

### 2.3 数据输入输出

本节案例使用`MedQA`数据集，**输入数据格式**如下：

```json
{"question": "A 65-year-old male is treated for anal carcinoma with therapy including external beam radiation. How does radiation affect cancer cells?", "answer": "Induces breaks in double-stranded DNA", "options": {"A": "Induces the formation of thymidine dimers", "B": "Induces the formation of disulfide bonds", "C": "Induces G/T and A/C pair formation", "D": "Induces deamination of cytosine", "E": "Induces breaks in double-stranded DNA"}, "meta_info": "step1", "answer_idx": "E"}
```

运行程序后的输出结果如下所示：

```json
{"question": "A 3-mont......ch of the following abnormalities?", "options": {"A": "22q11 deletion", "B": "Deletion of genes on chromosome 7", "C": "Lithium exposure in utero", "D": "Maternal alcohol consumption", "E": "Retinoic acid exposure in utero"}, "pred_answer": "B", "gold_answer": "A", "question_domains": ["Pediatrics", "Cardiology", "Neonatology", "Pulmonology", "Critical Care Medicine"], "option_domains": ["Cardiology", "Pediatrics"], "question_analyses": {"Pediatrics": "The medical scenario ...... congestion..", "Cardiology": "The described  ...... anomalies. 2..", "Neonatology": "The medical ........ arteriosus (PDA)..", "Pulmonology": "The medical ........ definitively..", "Critical Care Medicine": "The medical ........ hypertension.."}, "option_analyses": {"Cardiology": "Based ........ utero**.", "Pediatrics": "Based ........symptoms."}, "syn_report": "Question: A 3-month-old ........reports. \n", "vote_history": [{"Pediatrics": "no", "Cardiology": "no", "Neonatology": "no", "Pulmonology": "no", "Critical Care Medicine": "no"}, {"Pediatrics": "no", "Cardiology": "no", "Neonatology": "no", "Pulmonology": "no", "Critical Care Medicine": "no"}, {"Pediatrics": "no", "Cardiology": "no", "Neonatology": "no", "Pulmonology": "no", "Critical Care Medicine": "no"}], "revision_history": [{"Pediatrics": "Revisions: ...reports.", "Cardiology": "Revisions:... described.", "Neonatology": "Revisions: ...causes.", "Pulmonology": "Revisions: ...reports.", "Critical Care Medicine": "Revisions: ...factors."}, {"Pediatrics": "Revisions:... reports.", "Cardiology": "Revisions:...reports.", "Neonatology": "Revisions:... reports.", "Pulmonology": "Revisions: ... reports.", "Critical Care Medicine": "Revisions: ... reports."}, {"Pediatrics": "Revisions: ... reports.']", "Cardiology": "Revisions: ... reports.']", "Neonatology": "Revisions:... reports.']", "Pulmonology": "Revisions: ['The most ...reports.']", "Critical Care Medicine": "Revisions: .... reports.']"}], "syn_repo_history": ["Question: A 3-month-old ........ reports. \n"], "raw_output": "'''Option: [B]'''"}
```

输出结果中保留了所有的推理阶段的输出。

## 三、案例二：Multi-Agents-Debate

### 3.1 Multi-Agents-Debate

案例是来自**EMNLP 2024** 的一篇工作《[Encouraging Divergent Thinking in Large Language Models through Multi-Agent Debate](https://aclanthology.org/2024.emnlp-main.992.pdf)》。本文针对自我反思过程中容易出现的**思维退化(Degeneration of Thought, DOT)**问题，提出了**多智能体辩论(Multi-Agent Debate, MAD)**框架。论文首先定义了DOT问题: **一旦语言模型建立了对其解决方案的信心,即使初始立场是错误的,后续也无法通过自我反思生成新的思维。**

为了解决DOT问题,作者设计了MAD框架,其中包含多个智能体按顺序表达论点,一位裁判负责监督整个辩论过程并输出最终答案。这种框架鼓励语言模型进行发散性思考,探索不同的思路去寻找正确解决方案，并将其运用到机器翻译方向。

下面是这篇论文的整体框架图。

![image-20250610224545827](C:\Users\21182\AppData\Roaming\Typora\typora-user-images\image-20250610224545827.png)

作者列举了一个反直觉的数学问题，以此来佐证大模型在回答问题时会陷入DOT并输出一个错误的答案，而作者通过正反方辩论并由裁判裁断的情况，来证明多智能体辩论的优势。

### 3.2 源码解析

1. 下载论文的源码：

   ```shell
   # 返回LLM目录
   cd ~/LLM
   
   # 创建agent文件夹
   mkdir agent2
   cd agent2
   
   # clone 源码https://github.com/gersteinlab/MedAgents.git
   https://github.com/Skytliang/Multi-Agents-Debate
   ```

2. 安装必要的依赖库：

   ```shell
   pip3 install -r requirements.txt
   ```

3. 源码解析`debate4tran.py`

```python
"""
MAD: Multi-Agent Debate with Large Language Models
Copyright (C) 2023  The MAD Team

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import re
import os
import json
import random
# random.seed(0)
import argparse
from langcodes import Language
from utils.agent import Agent
from datetime import datetime
from tqdm import tqdm

# 正方、反方、裁判
NAME_LIST=[
    "Affirmative side",
    "Negative side",
    "Moderator",
]
"""辩论参与者类，继承自基础智能体类
    功能：代表辩论中的一方角色（正方/反方/主持人）
    参数：
        model_name: 使用的AI模型名称
        name: 参与者名称
        temperature: 生成文本的随机性控制
        openai_api_key: OpenAI API密钥
        sleep_time: API请求间的延迟时间（防限速）
    """
class DebatePlayer(Agent):
    def __init__(self, model_name: str, name: str, temperature:float, openai_api_key: str, sleep_time: float) -> None:
        super(DebatePlayer, self).__init__(model_name, name, temperature, openai_api_key, sleep_time)
        self.openai_api_key = openai_api_key

    """辩论管理类
    功能：组织完整的辩论流程，管理参与者，控制辩论轮次，保存结果
    核心参数：
        model_name: 使用的AI模型（默认gpt-4o）
        temperature: 生成文本的随机性控制
        num_players: 参与者数量（固定为3）
        save_file_dir: 结果保存目录
        openai_api_key: API密钥
        prompts_path: 提示词配置文件路径
        max_round: 最大辩论轮次（默认3轮）
        sleep_time: API请求间的延迟
    """
class Debate:
    """初始化提示词模板
        功能：替换提示词中的占位符（语言/原文/翻译等）
        处理：将##src_lng##,##tgt_lng##等标记替换为实际值
        """
    def __init__(self,
            # model_name: str='gpt-3.5-turbo', 
            model_name: str='gpt-4o',
            temperature: float=0, 
            num_players: int=3, 
            save_file_dir: str=None,
            openai_api_key: str=None,
            prompts_path: str=None,
            max_round: int=3,
            sleep_time: float=0
        ) -> None:
        
        self.model_name = model_name
        self.temperature = temperature
        self.num_players = num_players
        self.save_file_dir = save_file_dir
        self.openai_api_key = openai_api_key
        self.max_round = max_round
        self.sleep_time = sleep_time

        # init save file
        now = datetime.now()
        current_time = now.strftime("%Y-%m-%d_%H:%M:%S")
        # print(f"===== Debate Start at {self.openai_api_key} =====\n")
        self.save_file = {
            'start_time': current_time,
            'end_time': '',
            'model_name': model_name,
            'temperature': temperature,
            'num_players': num_players,
            'success': False,
            "src_lng": "",
            "tgt_lng": "",
            'source': '',
            'reference': '',
            'base_translation': '',
            "debate_translation": '',
            "Reason": '',
            "Supported Side": '',
            'players': {},
        }
        prompts = json.load(open(prompts_path))
        self.save_file.update(prompts)
        self.init_prompt()

        if self.save_file['base_translation'] == "":
            self.create_base()

        # creat&init agents
        self.creat_agents()
        self.init_agents()

    """初始化提示词模板
        功能：替换提示词中的占位符（语言/原文/翻译等）
        处理：将##src_lng##,##tgt_lng##等标记替换为实际值
        """

    def init_prompt(self):
        def prompt_replace(key):
            self.save_file[key] = self.save_file[key].replace("##src_lng##", self.save_file["src_lng"]).replace("##tgt_lng##", self.save_file["tgt_lng"]).replace("##source##", self.save_file["source"]).replace("##base_translation##", self.save_file["base_translation"])
        prompt_replace("base_prompt")
        prompt_replace("player_meta_prompt")
        prompt_replace("moderator_meta_prompt")
        prompt_replace("judge_prompt_last2")
    """创建基础翻译
            功能：使用基础提示词生成初始翻译
            流程：
                1. 创建临时智能体
                2. 发送基础翻译指令
                3. 将结果存入配置
            """

    def create_base(self):
        print(f"\n===== Translation Task =====\n{self.save_file['base_prompt']}\n")
        agent = DebatePlayer(model_name=self.model_name, name='Baseline', temperature=self.temperature, openai_api_key=self.openai_api_key, sleep_time=self.sleep_time)
        agent.add_event(self.save_file['base_prompt'])
        base_translation = agent.ask()
        agent.add_memory(base_translation)
        self.save_file['base_translation'] = base_translation
        self.save_file['affirmative_prompt'] = self.save_file['affirmative_prompt'].replace("##base_translation##", base_translation)
        self.save_file['players'][agent.name] = agent.memory_lst

    """创建辩论参与者
        功能：实例化正方/反方/主持人三个角色
        输出：
            self.players: 参与者列表
            self.affirmative: 正方对象
            self.negative: 反方对象
            self.moderator: 主持人对象
        """
    def creat_agents(self):
        # creates players
        self.players = [
            DebatePlayer(model_name=self.model_name, name=name, temperature=self.temperature, openai_api_key=self.openai_api_key, sleep_time=self.sleep_time) for name in NAME_LIST
        ]
        self.affirmative = self.players[0]
        self.negative = self.players[1]
        self.moderator = self.players[2]

    """初始化参与者
        功能：设置各角色的初始提示词并启动第一轮辩论
        流程：
            1. 设置正反方的基础提示词
            2. 设置主持人的专属提示词
            3. 进行首轮观点陈述
        """
    def init_agents(self):
        # start: set meta prompt
        self.affirmative.set_meta_prompt(self.save_file['player_meta_prompt'])
        self.negative.set_meta_prompt(self.save_file['player_meta_prompt'])
        self.moderator.set_meta_prompt(self.save_file['moderator_meta_prompt'])
        
        # start: first round debate, state opinions
        print(f"===== Debate Round-1 =====\n")
        self.affirmative.add_event(self.save_file['affirmative_prompt'])
        self.aff_ans = self.affirmative.ask()
        self.affirmative.add_memory(self.aff_ans)

        self.negative.add_event(self.save_file['negative_prompt'].replace('##aff_ans##', self.aff_ans))
        self.neg_ans = self.negative.ask()
        self.negative.add_memory(self.neg_ans)

        self.moderator.add_event(self.save_file['moderator_prompt'].replace('##aff_ans##', self.aff_ans).replace('##neg_ans##', self.neg_ans).replace('##round##', 'first'))
        self.mod_ans = self.moderator.ask()
        self.moderator.add_memory(self.mod_ans)
        def clean_json_string(json_str):
        # 去除开头和结尾的 '''、json、```json
            pattern = r'^(?:```json|```|json)*\s*(.*?)\s*(?:```)*$'
            cleaned_str = re.sub(pattern, r'\1', json_str, flags=re.DOTALL)
            return cleaned_str.strip()
        self.mod_ans = clean_json_string(self.mod_ans)
        self.mod_ans = eval(self.mod_ans)


    def round_dct(self, num: int):
        dct = {
            1: 'first', 2: 'second', 3: 'third', 4: 'fourth', 5: 'fifth', 6: 'sixth', 7: 'seventh', 8: 'eighth', 9: 'ninth', 10: 'tenth'
        }
        return dct[num]
            
    def save_file_to_json(self, id):
        now = datetime.now()
        current_time = now.strftime("%Y-%m-%d_%H:%M:%S")
        save_file_path = os.path.join(self.save_file_dir, f"{id}.json")
        
        self.save_file['end_time'] = current_time
        json_str = json.dumps(self.save_file, ensure_ascii=False, indent=4)
        with open(save_file_path, 'w') as f:
            f.write(json_str)

    """全局广播消息
        功能：向所有参与者发送系统消息
        用途：主持人宣布公共信息
        """
    def broadcast(self, msg: str):
        """Broadcast a message to all players. 
        Typical use is for the host to announce public information

        Args:
            msg (str): the message
        """
        # print(msg)
        for player in self.players:
            player.add_event(msg)

    """角色发言
        功能：特定角色向其他参与者发言
        特点：自动添加说话者标识前缀
        """
    def speak(self, speaker: str, msg: str):
        """The speaker broadcast a message to all other players. 

        Args:
            speaker (str): name of the speaker
            msg (str): the message
        """
        if not msg.startswith(f"{speaker}: "):
            msg = f"{speaker}: {msg}"
        # print(msg)
        for player in self.players:
            if player.name != speaker:
                player.add_event(msg)

    def ask_and_speak(self, player: DebatePlayer):
        ans = player.ask()
        player.add_memory(ans)
        self.speak(player.name, ans)

    """运行辩论流程
        核心逻辑：
            1. 进行max_round-1轮后续辩论
            2. 每轮：正反方互相反驳 → 主持人总结
            3. 若主持人产出最终翻译则提前终止
            4. 若达到最大轮次仍未产出，启用法官裁决
        """
    def run(self):

        for round in range(self.max_round - 1):

            if self.mod_ans["debate_translation"] != '':
                break
            else:
                print(f"===== Debate Round-{round+2} =====\n")
                self.affirmative.add_event(self.save_file['debate_prompt'].replace('##oppo_ans##', self.neg_ans))
                self.aff_ans = self.affirmative.ask()
                self.affirmative.add_memory(self.aff_ans)

                self.negative.add_event(self.save_file['debate_prompt'].replace('##oppo_ans##', self.aff_ans))
                self.neg_ans = self.negative.ask()
                self.negative.add_memory(self.neg_ans)

                self.moderator.add_event(self.save_file['moderator_prompt'].replace('##aff_ans##', self.aff_ans).replace('##neg_ans##', self.neg_ans).replace('##round##', self.round_dct(round+2)))
                self.mod_ans = self.moderator.ask()
                print(f"===== Moderator Answer =====\n{self.mod_ans}\n")
                self.moderator.add_memory(self.mod_ans)
                def clean_json_string(json_str):
                # 去除开头和结尾的 '''、json、```json
                    pattern = r'^(?:```json|```|json)*\s*(.*?)\s*(?:```)*$'
                    cleaned_str = re.sub(pattern, r'\1', json_str, flags=re.DOTALL)
                    return cleaned_str.strip()
                self.mod_ans = clean_json_string(self.mod_ans)
                self.mod_ans = eval(self.mod_ans)

        if self.mod_ans["debate_translation"] != '':
            self.save_file.update(self.mod_ans)
            self.save_file['success'] = True

        # ultimate deadly technique.
        else:
            judge_player = DebatePlayer(model_name=self.model_name, name='Judge', temperature=self.temperature, openai_api_key=self.openai_api_key, sleep_time=self.sleep_time)
            aff_ans = self.affirmative.memory_lst[2]['content']
            neg_ans = self.negative.memory_lst[2]['content']

            judge_player.set_meta_prompt(self.save_file['moderator_meta_prompt'])

            # extract answer candidates
            judge_player.add_event(self.save_file['judge_prompt_last1'].replace('##aff_ans##', aff_ans).replace('##neg_ans##', neg_ans))
            ans = judge_player.ask()
            judge_player.add_memory(ans)

            # select one from the candidates
            judge_player.add_event(self.save_file['judge_prompt_last2'])
            ans = judge_player.ask()
            judge_player.add_memory(ans)
            
            ans = eval(ans)
            if ans["debate_translation"] != '':
                self.save_file['success'] = True
                # save file
            self.save_file.update(ans)
            self.players.append(judge_player)

        for player in self.players:
            self.save_file['players'][player.name] = player.memory_lst


def parse_args():
    parser = argparse.ArgumentParser("", formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument("-i", "--input-file", type=str, required=True, help="Input file path")
    parser.add_argument("-o", "--output-dir", type=str, required=True, help="Output file dir")
    parser.add_argument("-lp", "--lang-pair", type=str, required=True, help="Language pair")
    parser.add_argument("-k", "--api-key", type=str, required=True, help="OpenAI api key")
    parser.add_argument("-m", "--model-name", type=str, default="gpt-3.5-turbo", help="Model name")
    parser.add_argument("-t", "--temperature", type=float, default=0, help="Sampling temperature")

    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()
    openai_api_key = args.api_key
    # print(f"Using OpenAI API Key: {openai_api_key}")

    current_script_path = os.path.abspath(__file__)
    MAD_path = current_script_path.rsplit("/", 2)[0]

    src_lng, tgt_lng = args.lang_pair.split('-')
    src_full = Language.make(language=src_lng).display_name()
    tgt_full = Language.make(language=tgt_lng).display_name()

    config = json.load(open(f"{MAD_path}/code/utils/config4tran.json", "r"))

    inputs = open(args.input_file, "r").readlines()
    inputs = [l.strip() for l in inputs]

    save_file_dir = args.output_dir
    if not os.path.exists(save_file_dir):
            os.mkdir(save_file_dir)

    for id, input in enumerate(tqdm(inputs[:4])):
        # files = os.listdir(save_file_dir)
        # if f"{id}.json" in files:
        #     continue

        prompts_path = f"{save_file_dir}/{id}-config.json"

        config['source'] = input.split('\t')[0]
        config['reference'] = input.split('\t')[1]
        config['src_lng'] = src_full
        config['tgt_lng'] = tgt_full

        with open(prompts_path, 'w') as file:
            json.dump(config, file, ensure_ascii=False, indent=4)

        debate = Debate(save_file_dir=save_file_dir, num_players=3, openai_api_key=openai_api_key, prompts_path=prompts_path, temperature=0, sleep_time=0)
        debate.run()
        debate.save_file_to_json(id)


```

4. 源码解析`agent.py`

```python

import re
import json
import openai
import backoff
import time
from openai.error import RateLimitError, APIError, ServiceUnavailableError, APIConnectionError
from .openai_utils import OutOfQuotaException, AccessTerminatedException
from .openai_utils import num_tokens_from_string, model2max_context

support_models = ['gpt-3.5-turbo', 'gpt-3.5-turbo-0301', 'gpt-4', 'gpt-4-0314','gpt-4o','ep-20250503224120-sbwk8','qwen3-32b']
"""智能体基类
    功能：封装与AI模型的交互逻辑，维护对话记忆
    核心参数：
        model_name: 使用的AI模型
        name: 智能体名称
        temperature: 生成随机性控制
        api_key: OpenAI API密钥
        sleep_time: 请求延迟时间
    
    关键方法：
        set_meta_prompt(): 设置系统级角色提示词
        add_event(): 添加用户消息事件
        add_memory(): 添加AI生成的记忆
        ask(): 核心查询方法（带自动token计算）
        ask_single_turn(): 单轮对话快捷方法
    """
class Agent:
    def __init__(self, model_name: str, name: str, temperature: float, api_key: str, sleep_time: float = 0) -> None:
        """Create an agent
        Args:
            model_name(str): model name
            name (str): name of this agent
            temperature (float): higher values make the output more random, while lower values make it more focused and deterministic
            sleep_time (float): sleep because of rate limits
        """
        self.model_name = model_name
        self.name = name
        self.temperature = temperature
        self.memory_lst = []
        self.api_key = api_key
        self.sleep_time = sleep_time
        self.meta_prompt = None
        self.enable_thinking = False

    """带重试机制的API查询
        功能：执行实际API请求，处理各类异常
        特性：
            - 指数退避重试策略
            - 自动休眠避免限速
            - 异常分类处理（配额耗尽/服务不可用等）
        """
    @backoff.on_exception(backoff.expo, (RateLimitError, APIError, ServiceUnavailableError, APIConnectionError), max_tries=20)
    def query(self, messages: "list[dict]", max_tokens: int, api_key: str, temperature: float) -> str:
        
        """Make a query to OpenAI API with retry support"""
        time.sleep(self.sleep_time)

        if max_tokens <= 0:
            raise ValueError(f"Invalid max_tokens: {max_tokens}. Must be positive.")

        assert self.model_name in support_models, f"Not support {self.model_name}. Choices: {support_models}"

        openai.api_key = api_key
        # 小爱
        openai.api_base = "https://pro.xiaoai.plus/v1"

        try:
            response = openai.ChatCompletion.create(
                model=self.model_name,
                messages=messages,
                temperature=temperature,
                max_tokens=max_tokens,

            )
            gen = response['choices'][0]['message']['content']
            return gen

        except openai.error.InvalidRequestError as e:
            if "quota exceeded" in str(e).lower():
                raise OutOfQuotaException(api_key)
            elif "access terminated" in str(e).lower():
                raise AccessTerminatedException(api_key)
            else:
                raise  # 让 backoff 处理其他错误
    # 设置system prompt，每轮对话的一个通用指令
    def set_meta_prompt(self, meta_prompt: str):
        """Set the meta_prompt
        Args:
            meta_prompt (str): the meta prompt
        """
        self.meta_prompt = meta_prompt
        self.memory_lst.append({"role": "system", "content": f"{meta_prompt}"})
        
    #这是用户prompt，调用时与system prompt拼接，送入智能体中。同时add_event函数将改变的用户prompt添加到智能体的memory中。
    def add_event(self, event: str):
        """Add an new event in the memory
        Args:
            event (str): string that describe the event.
        """
        # print(1)
        self.memory_lst.append({"role": "user", "content": f"{event}"})
        
    #智能体每轮的回复，添加到智能体的memory中。
    def add_memory(self, memory: str):
        """Monologue in the memory
        Args:
            memory (str): string that generated by the model in the last round.
        """
        self.memory_lst.append({"role": "assistant", "content": f"{memory}"})
        print(f"----- {self.name} -----\n{memory}\n")
    
    """智能提问入口
        流程：
            1. 计算当前对话token数
            2. 动态确定最大输出token
            3. 调用query()执行请求
        """
    def ask(self, temperature: float = None, api_key: str = ''):
        """Query for answer
        Args:
        """
        # query
        num_context_token = sum([num_tokens_from_string(m["content"], self.model_name) for m in self.memory_lst])
        max_token = model2max_context[self.model_name] - num_context_token
        return self.query(self.memory_lst, max_token, api_key=self.api_key, temperature=temperature if temperature else self.temperature)
    
    def ask_single_turn(self, event_prompt: str, meta_prompt: str = None) -> str:
        """
        单轮对话调用：不使用历史，只用系统 prompt 和当前 prompt。
        
        Args:
            event_prompt (str): 当前 user 输入
            meta_prompt (str, optional): 若提供则覆盖原设定；否则用已有 self.meta_prompt

        Returns:
            str: 模型回复
        """
        # 清空历史
        self.memory_lst = []

        # 选用系统 prompt（优先使用外部提供的 meta_prompt）
        system_prompt = meta_prompt if meta_prompt is not None else self.meta_prompt
        if system_prompt is not None:
            self.memory_lst.append({"role": "system", "content": system_prompt})

        # 添加 user prompt
        self.memory_lst.append({"role": "user", "content": event_prompt})

        # 调用模型
        response = self.ask()

        return response
```

### 2.3 数据输入输出

对于项目自带的数据的输入输出结果：

输入为需要翻译的中文，以及基准翻译：

```
他想拉同村的干部一起下水去贩毒。	
He wants to take the cadres of the same village to sell drugs with him.
```

输出为辩论过程以及结果：

```python
{
    "start_time": "2025-06-10_10:57:26",
    "end_time": "2025-06-10_10:57:51",
    "model_name": "gpt-4o",
    "temperature": 0,
    "num_players": 3,
    "success": true,
    "src_lng": "Chinese",
    "tgt_lng": "English",
    "source": "他想拉同村的干部一起下水去贩毒。",
    "reference": "He wants to take the cadres of the same village to sell drugs with him.",
    "base_translation": "He wanted to drag the village cadres into drug trafficking with him.",
    "debate_translation": "He wanted to drag the village cadres into drug trafficking with him.",
    "Reason": "The affirmative side's translation captures the coercive nature implied by '拉' with 'drag...into' and uses 'cadres' to reflect the specific organizational role of '干部' in a Chinese context. Additionally, 'drug trafficking' better conveys the serious and organized nature of the activity, aligning more closely with the original text's implications.",
    "Supported Side": "Affirmative",
    "players": {
        "Baseline": [
            {
                "role": "user",
                "content": "Translate the following text from Chinese to English: 他想拉同村的干部一起下水去贩毒。"
            },
            {
                "role": "assistant",
                "content": "He wanted to drag the village cadres into drug trafficking with him."
            }
        ],
        "Affirmative side": [
            {
                "role": "system",
                "content": "You are a debater. Hello and welcome to the translation competition, which will be conducted in a debate format. It's not necessary to fully agree with each other's perspectives, as our objective is to find the correct translation.\nThe debate topic is stated as follows:\nWhat is the correct English translation of the following Chinese text: \"他想拉同村的干部一起下水去贩毒。\""
            },
            {
                "role": "user",
                "content": "You think the correct translation is: He wanted to drag the village cadres into drug trafficking with him. Restate the translation and provide your reasons."
            },
            {
                "role": "assistant",
                "content": "The translation I propose is: \"He wanted to drag the village cadres into drug trafficking with him.\"\n\nReasons for this translation:\n\n1. **Subject Identification**: The pronoun \"他\" translates directly to \"he,\" indicating the subject of the sentence is male.\n\n2. **Action Verb**: \"想\" means \"wanted\" or \"intended,\" showing the subject's desire or intention.\n\n3. **Phrase \"拉...一起下水\"**: This phrase can be translated as \"drag...into\" or \"pull...into,\" with \"下水\" literally meaning \"get into the water,\" but idiomatically it means to involve someone in a risky or illegal activity. In this context, it suggests coercing or persuading others to join in an illicit activity.\n\n4. **Target of Action**: \"同村的干部\" refers to \"the village cadres,\" indicating the specific group of people the subject wants to involve. \"干部\" translates to \"cadres,\" which are officials or leaders within a community or organization.\n\n5. **Activity Specification**: \"贩毒\" translates to \"drug trafficking,\" specifying the illegal activity the subject intends to involve the village cadres in.\n\nOverall, the translation captures the essence of the original text by conveying the subject's intention to involve village officials in drug trafficking, maintaining both the literal and idiomatic meanings of the Chinese text."
            },
            {
                "role": "user",
                "content": "The translation I propose is: \"He wanted to pull the village officials into drug dealing.\"\n\nReasons for this translation:\n\n1. **Subject Identification**: The pronoun \"他\" is accurately translated as \"he,\" indicating the subject is male.\n\n2. **Action Verb**: \"想\" is correctly translated as \"wanted,\" reflecting the subject's desire or intention.\n\n3. **Phrase \"拉...一起下水\"**: While \"拉...一起下水\" can be translated as \"drag...into,\" I chose \"pull...into\" to emphasize the act of persuading or involving others in an activity. \"下水\" idiomatically means to involve someone in a risky or illegal activity, aligning with the context of the sentence.\n\n4. **Target of Action**: \"同村的干部\" translates to \"the village officials.\" While \"干部\" can mean \"cadres,\" in this context, \"officials\" is a more commonly understood term in English, referring to the local leaders or authorities within the village.\n\n5. **Activity Specification**: \"贩毒\" translates to \"drug dealing.\" While \"drug trafficking\" is a valid translation, \"drug dealing\" is often used interchangeably and may better capture the direct involvement in the illegal activity.\n\nThis translation maintains the original meaning while using terms that are more commonly understood in English, ensuring clarity and accuracy in conveying the subject's intention to involve village officials in drug dealing.\n\nDo you agree with my perspective? Please provide your reasons and translation."
            },
            {
                "role": "assistant",
                "content": "I appreciate your perspective, but I maintain that the translation \"He wanted to drag the village cadres into drug trafficking with him\" is more accurate for the following reasons:\n\n1. **Phrase \"拉...一起下水\"**: While \"pull...into\" is a valid translation, \"drag...into\" better captures the coercive or forceful nature implied by \"拉\" in this context. The idiomatic expression \"下水\" suggests involving someone in a risky or illegal activity, and \"drag\" emphasizes the unwilling or reluctant participation of the village cadres.\n\n2. **Target of Action**: \"干部\" is often translated as \"cadres,\" which is a term used to describe officials or leaders within a specific organizational or political context, particularly in Chinese settings. \"Cadres\" is a more precise term that reflects the hierarchical and administrative role these individuals play within the village, whereas \"officials\" is broader and may not fully capture the specific connotation of \"干部.\"\n\n3. **Activity Specification**: \"贩毒\" is more accurately translated as \"drug trafficking\" rather than \"drug dealing.\" \"Drug trafficking\" encompasses the broader illegal trade and distribution of drugs, which aligns with the serious nature of the activity implied in the original text. \"Drug dealing\" can imply smaller-scale transactions, whereas \"trafficking\" suggests a more organized and extensive operation.\n\nOverall, my translation aims to preserve the nuances and specific connotations of the original Chinese text, ensuring that the seriousness and organizational context are accurately conveyed in English."
            }
        ],
        "Negative side": [
            {
                "role": "system",
                "content": "You are a debater. Hello and welcome to the translation competition, which will be conducted in a debate format. It's not necessary to fully agree with each other's perspectives, as our objective is to find the correct translation.\nThe debate topic is stated as follows:\nWhat is the correct English translation of the following Chinese text: \"他想拉同村的干部一起下水去贩毒。\""
            },
            {
                "role": "user",
                "content": "The translation I propose is: \"He wanted to drag the village cadres into drug trafficking with him.\"\n\nReasons for this translation:\n\n1. **Subject Identification**: The pronoun \"他\" translates directly to \"he,\" indicating the subject of the sentence is male.\n\n2. **Action Verb**: \"想\" means \"wanted\" or \"intended,\" showing the subject's desire or intention.\n\n3. **Phrase \"拉...一起下水\"**: This phrase can be translated as \"drag...into\" or \"pull...into,\" with \"下水\" literally meaning \"get into the water,\" but idiomatically it means to involve someone in a risky or illegal activity. In this context, it suggests coercing or persuading others to join in an illicit activity.\n\n4. **Target of Action**: \"同村的干部\" refers to \"the village cadres,\" indicating the specific group of people the subject wants to involve. \"干部\" translates to \"cadres,\" which are officials or leaders within a community or organization.\n\n5. **Activity Specification**: \"贩毒\" translates to \"drug trafficking,\" specifying the illegal activity the subject intends to involve the village cadres in.\n\nOverall, the translation captures the essence of the original text by conveying the subject's intention to involve village officials in drug trafficking, maintaining both the literal and idiomatic meanings of the Chinese text.\n\nYou disagree with my translation. Provide your translation and reasons."
            },
            {
                "role": "assistant",
                "content": "The translation I propose is: \"He wanted to pull the village officials into drug dealing.\"\n\nReasons for this translation:\n\n1. **Subject Identification**: The pronoun \"他\" is accurately translated as \"he,\" indicating the subject is male.\n\n2. **Action Verb**: \"想\" is correctly translated as \"wanted,\" reflecting the subject's desire or intention.\n\n3. **Phrase \"拉...一起下水\"**: While \"拉...一起下水\" can be translated as \"drag...into,\" I chose \"pull...into\" to emphasize the act of persuading or involving others in an activity. \"下水\" idiomatically means to involve someone in a risky or illegal activity, aligning with the context of the sentence.\n\n4. **Target of Action**: \"同村的干部\" translates to \"the village officials.\" While \"干部\" can mean \"cadres,\" in this context, \"officials\" is a more commonly understood term in English, referring to the local leaders or authorities within the village.\n\n5. **Activity Specification**: \"贩毒\" translates to \"drug dealing.\" While \"drug trafficking\" is a valid translation, \"drug dealing\" is often used interchangeably and may better capture the direct involvement in the illegal activity.\n\nThis translation maintains the original meaning while using terms that are more commonly understood in English, ensuring clarity and accuracy in conveying the subject's intention to involve village officials in drug dealing."
            },
            {
                "role": "user",
                "content": "I appreciate your perspective, but I maintain that the translation \"He wanted to drag the village cadres into drug trafficking with him\" is more accurate for the following reasons:\n\n1. **Phrase \"拉...一起下水\"**: While \"pull...into\" is a valid translation, \"drag...into\" better captures the coercive or forceful nature implied by \"拉\" in this context. The idiomatic expression \"下水\" suggests involving someone in a risky or illegal activity, and \"drag\" emphasizes the unwilling or reluctant participation of the village cadres.\n\n2. **Target of Action**: \"干部\" is often translated as \"cadres,\" which is a term used to describe officials or leaders within a specific organizational or political context, particularly in Chinese settings. \"Cadres\" is a more precise term that reflects the hierarchical and administrative role these individuals play within the village, whereas \"officials\" is broader and may not fully capture the specific connotation of \"干部.\"\n\n3. **Activity Specification**: \"贩毒\" is more accurately translated as \"drug trafficking\" rather than \"drug dealing.\" \"Drug trafficking\" encompasses the broader illegal trade and distribution of drugs, which aligns with the serious nature of the activity implied in the original text. \"Drug dealing\" can imply smaller-scale transactions, whereas \"trafficking\" suggests a more organized and extensive operation.\n\nOverall, my translation aims to preserve the nuances and specific connotations of the original Chinese text, ensuring that the seriousness and organizational context are accurately conveyed in English.\n\nDo you agree with my perspective? Please provide your reasons and translation."
            },
            {
                "role": "assistant",
                "content": "I understand your reasoning, but I still believe that my translation, \"He wanted to pull the village officials into drug dealing,\" is more suitable for the following reasons:\n\n1. **Phrase \"拉...一起下水\"**: While \"drag...into\" does suggest a more forceful action, \"pull...into\" can also imply persuasion or coaxing, which might be more fitting depending on the context. The idiomatic expression \"下水\" indeed suggests involving someone in a risky or illegal activity, but \"pull\" can capture both the coercive and persuasive aspects without assuming the level of force.\n\n2. **Target of Action**: While \"cadres\" is a term often used in Chinese contexts, \"officials\" is more widely understood in English and still accurately conveys the idea of local leaders or authorities. The term \"officials\" can encompass the roles and responsibilities of \"干部\" without losing the hierarchical implication, making it more accessible to a broader audience.\n\n3. **Activity Specification**: \"Drug dealing\" is often used interchangeably with \"drug trafficking\" in English, but it can imply direct involvement in the sale and distribution of drugs, which might be more relatable to the average English speaker. While \"drug trafficking\" suggests a larger scale, \"drug dealing\" can still convey the seriousness of the activity without assuming the scale of operation.\n\nIn summary, my translation aims to balance accuracy with clarity and accessibility, ensuring that the intended meaning is conveyed effectively to an English-speaking audience. However, I acknowledge that both translations have their merits, and the choice may depend on the specific context and audience."
            }
        ],
        "Moderator": [
            {
                "role": "system",
                "content": "You are a moderator. There will be two debaters involved in a translation debate competition. They will present their translations and discuss their perspectives on the correct English translation of the given Chinese text: \"他想拉同村的干部一起下水去贩毒。\". At the end of each round, you will evaluate the translation candidates based on the following criteria:\n1. Accuracy: The degree to which the translation captures the original meaning of the source text.\n2. Fluency: The readability and naturalness of the translation in English."
            },
            {
                "role": "user",
                "content": "Now the first round of debate for both sides has ended.\n\nAffirmative side arguing:\nThe translation I propose is: \"He wanted to drag the village cadres into drug trafficking with him.\"\n\nReasons for this translation:\n\n1. **Subject Identification**: The pronoun \"他\" translates directly to \"he,\" indicating the subject of the sentence is male.\n\n2. **Action Verb**: \"想\" means \"wanted\" or \"intended,\" showing the subject's desire or intention.\n\n3. **Phrase \"拉...一起下水\"**: This phrase can be translated as \"drag...into\" or \"pull...into,\" with \"下水\" literally meaning \"get into the water,\" but idiomatically it means to involve someone in a risky or illegal activity. In this context, it suggests coercing or persuading others to join in an illicit activity.\n\n4. **Target of Action**: \"同村的干部\" refers to \"the village cadres,\" indicating the specific group of people the subject wants to involve. \"干部\" translates to \"cadres,\" which are officials or leaders within a community or organization.\n\n5. **Activity Specification**: \"贩毒\" translates to \"drug trafficking,\" specifying the illegal activity the subject intends to involve the village cadres in.\n\nOverall, the translation captures the essence of the original text by conveying the subject's intention to involve village officials in drug trafficking, maintaining both the literal and idiomatic meanings of the Chinese text.\n\nNegative side arguing: The translation I propose is: \"He wanted to pull the village officials into drug dealing.\"\n\nReasons for this translation:\n\n1. **Subject Identification**: The pronoun \"他\" is accurately translated as \"he,\" indicating the subject is male.\n\n2. **Action Verb**: \"想\" is correctly translated as \"wanted,\" reflecting the subject's desire or intention.\n\n3. **Phrase \"拉...一起下水\"**: While \"拉...一起下水\" can be translated as \"drag...into,\" I chose \"pull...into\" to emphasize the act of persuading or involving others in an activity. \"下水\" idiomatically means to involve someone in a risky or illegal activity, aligning with the context of the sentence.\n\n4. **Target of Action**: \"同村的干部\" translates to \"the village officials.\" While \"干部\" can mean \"cadres,\" in this context, \"officials\" is a more commonly understood term in English, referring to the local leaders or authorities within the village.\n\n5. **Activity Specification**: \"贩毒\" translates to \"drug dealing.\" While \"drug trafficking\" is a valid translation, \"drug dealing\" is often used interchangeably and may better capture the direct involvement in the illegal activity.\n\nThis translation maintains the original meaning while using terms that are more commonly understood in English, ensuring clarity and accuracy in conveying the subject's intention to involve village officials in drug dealing.\n\nYou, as the moderator, will evaluate both sides' translations and determine if there is a clear preference for a translation candidate. If so, please summarize your reasons for supporting affirmative/negative side and give the final translation that you think is correct, and the debate will conclude. If not, the debate will continue to the next round. Now please output your answer in json format, with the format as follows: {\"Whether there is a preference\": \"Yes or No\", \"Supported Side\": \"Affirmative or Negative\", \"Reason\": \"\", \"debate_translation\": \"\"}. Please strictly output in JSON format, do not output irrelevant content."
            },
            {
                "role": "assistant",
                "content": "```json\n{\"Whether there is a preference\": \"No\", \"Supported Side\": \"\", \"Reason\": \"Both translations accurately capture the subject's intention and the involvement of village leaders in an illegal activity. The choice between 'cadres' and 'officials' as well as 'drug trafficking' and 'drug dealing' does not significantly impact the accuracy or fluency of the translation.\", \"debate_translation\": \"\"}\n```"
            },
            {
                "role": "user",
                "content": "Now the second round of debate for both sides has ended.\n\nAffirmative side arguing:\nI appreciate your perspective, but I maintain that the translation \"He wanted to drag the village cadres into drug trafficking with him\" is more accurate for the following reasons:\n\n1. **Phrase \"拉...一起下水\"**: While \"pull...into\" is a valid translation, \"drag...into\" better captures the coercive or forceful nature implied by \"拉\" in this context. The idiomatic expression \"下水\" suggests involving someone in a risky or illegal activity, and \"drag\" emphasizes the unwilling or reluctant participation of the village cadres.\n\n2. **Target of Action**: \"干部\" is often translated as \"cadres,\" which is a term used to describe officials or leaders within a specific organizational or political context, particularly in Chinese settings. \"Cadres\" is a more precise term that reflects the hierarchical and administrative role these individuals play within the village, whereas \"officials\" is broader and may not fully capture the specific connotation of \"干部.\"\n\n3. **Activity Specification**: \"贩毒\" is more accurately translated as \"drug trafficking\" rather than \"drug dealing.\" \"Drug trafficking\" encompasses the broader illegal trade and distribution of drugs, which aligns with the serious nature of the activity implied in the original text. \"Drug dealing\" can imply smaller-scale transactions, whereas \"trafficking\" suggests a more organized and extensive operation.\n\nOverall, my translation aims to preserve the nuances and specific connotations of the original Chinese text, ensuring that the seriousness and organizational context are accurately conveyed in English.\n\nNegative side arguing: I understand your reasoning, but I still believe that my translation, \"He wanted to pull the village officials into drug dealing,\" is more suitable for the following reasons:\n\n1. **Phrase \"拉...一起下水\"**: While \"drag...into\" does suggest a more forceful action, \"pull...into\" can also imply persuasion or coaxing, which might be more fitting depending on the context. The idiomatic expression \"下水\" indeed suggests involving someone in a risky or illegal activity, but \"pull\" can capture both the coercive and persuasive aspects without assuming the level of force.\n\n2. **Target of Action**: While \"cadres\" is a term often used in Chinese contexts, \"officials\" is more widely understood in English and still accurately conveys the idea of local leaders or authorities. The term \"officials\" can encompass the roles and responsibilities of \"干部\" without losing the hierarchical implication, making it more accessible to a broader audience.\n\n3. **Activity Specification**: \"Drug dealing\" is often used interchangeably with \"drug trafficking\" in English, but it can imply direct involvement in the sale and distribution of drugs, which might be more relatable to the average English speaker. While \"drug trafficking\" suggests a larger scale, \"drug dealing\" can still convey the seriousness of the activity without assuming the scale of operation.\n\nIn summary, my translation aims to balance accuracy with clarity and accessibility, ensuring that the intended meaning is conveyed effectively to an English-speaking audience. However, I acknowledge that both translations have their merits, and the choice may depend on the specific context and audience.\n\nYou, as the moderator, will evaluate both sides' translations and determine if there is a clear preference for a translation candidate. If so, please summarize your reasons for supporting affirmative/negative side and give the final translation that you think is correct, and the debate will conclude. If not, the debate will continue to the next round. Now please output your answer in json format, with the format as follows: {\"Whether there is a preference\": \"Yes or No\", \"Supported Side\": \"Affirmative or Negative\", \"Reason\": \"\", \"debate_translation\": \"\"}. Please strictly output in JSON format, do not output irrelevant content."
            },
            {
                "role": "assistant",
                "content": "```json\n{\"Whether there is a preference\": \"Yes\", \"Supported Side\": \"Affirmative\", \"Reason\": \"The affirmative side's translation captures the coercive nature implied by '拉' with 'drag...into' and uses 'cadres' to reflect the specific organizational role of '干部' in a Chinese context. Additionally, 'drug trafficking' better conveys the serious and organized nature of the activity, aligning more closely with the original text's implications.\", \"debate_translation\": \"He wanted to drag the village cadres into drug trafficking with him.\"}\n```"
            }
        ]
    },
    "base_prompt": "Translate the following text from Chinese to English: 他想拉同村的干部一起下水去贩毒。",
    "player_meta_prompt": "You are a debater. Hello and welcome to the translation competition, which will be conducted in a debate format. It's not necessary to fully agree with each other's perspectives, as our objective is to find the correct translation.\nThe debate topic is stated as follows:\nWhat is the correct English translation of the following Chinese text: \"他想拉同村的干部一起下水去贩毒。\"",
    "moderator_meta_prompt": "You are a moderator. There will be two debaters involved in a translation debate competition. They will present their translations and discuss their perspectives on the correct English translation of the given Chinese text: \"他想拉同村的干部一起下水去贩毒。\". At the end of each round, you will evaluate the translation candidates based on the following criteria:\n1. Accuracy: The degree to which the translation captures the original meaning of the source text.\n2. Fluency: The readability and naturalness of the translation in English.",
    "affirmative_prompt": "You think the correct translation is: He wanted to drag the village cadres into drug trafficking with him. Restate the translation and provide your reasons.",
    "negative_prompt": "##aff_ans##\n\nYou disagree with my translation. Provide your translation and reasons.",
    "moderator_prompt": "Now the ##round## round of debate for both sides has ended.\n\nAffirmative side arguing:\n##aff_ans##\n\nNegative side arguing: ##neg_ans##\n\nYou, as the moderator, will evaluate both sides' translations and determine if there is a clear preference for a translation candidate. If so, please summarize your reasons for supporting affirmative/negative side and give the final translation that you think is correct, and the debate will conclude. If not, the debate will continue to the next round. Now please output your answer in json format, with the format as follows: {\"Whether there is a preference\": \"Yes or No\", \"Supported Side\": \"Affirmative or Negative\", \"Reason\": \"\", \"debate_translation\": \"\"}. Please strictly output in JSON format, do not output irrelevant content.",
    "judge_prompt_last1": "Affirmative side arguing: ##aff_ans##\n\nNegative side arguing: ##neg_ans##\n\nNow, what translation candidates do we have? Present them without reasons.",
    "judge_prompt_last2": "Therefore, what is the correct English translation of the following Chinese text: \"他想拉同村的干部一起下水去贩毒。\". Please summarize your reasons and give the final translation that you think is correct. Now please output your answer in json format, with the format as follows: {\"Reason\": \"\", \"debate_translation\": \"\"}. Please strictly output in JSON format, do not output irrelevant content.",
    "debate_prompt": "##oppo_ans##\n\nDo you agree with my perspective? Please provide your reasons and translation.",
    "Whether there is a preference": "Yes"
}
```

---

![](QLUNLP_logo.png)
